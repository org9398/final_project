---
title: "Data Science for Public Policy"
subtitle: "Final Project"
author: "Olivia Gomez, Alicia Helfrich, Allie Gleich, Edward Malcolm"
execute:
  warning: false
format:
  html:
    embed-resources: true
---

## Final Project

1\. Background and Literature Review: Describes your research question, why the question\
is important to governance, policy, or social sciences, and a brief review of the literature\
that is relevant to your research question. Note that it will likely not be feasible to\
conduct a thorough literature review for this project, but I expect you to show that you\
have at least engaged with the existing research in your focus area.

\
2. Data Sources: This section should describe each of your data sources that you are using\
for your analysis and include your code to access and read in the data. If the data access\
includes any manual steps that are not captured in the code (e.g. downloading files in a\
point-and-click manner) please document those steps here.

**Current Population Survey - 2022**

We are utilizing the Current Population Survey from 2022 as a major source of data for our analysis. This survey is conducted each year to capture statistical information on the population. The units of measurement are individual adults. The survey contains information on immigration demographic characteristics in addition to health insurance status. Below, we will utilize unsupervised machine learning techniques, specifically dimension reduction, to analyze the relationship between health and demographic characteristics and estimate a model, given that the survey has many correlated predictors. We will also use the data in a supervised machine learning capacity to predict health coverage status based on several demographic predictors.

We used the IPUMS to download the 2022 CPS data. We read in the data using the ipumsr package.

```{r, eval = FALSE}
library(ipumsr)
library(tidyverse)
library(tidymodels)
library(ggplot2)
library(corrplot)
library(VGAM)
library(rpart)
library(rpart.plot)
library(hardhat)
library(ranger)
library(recipes)
library(srvyr)
library(haven)
library(survey)
library(tidyclust)
library(GGally)
library(patchwork)
library(dotenv)
library(httr)
library(jsonlite)
```

```{r, eval = FALSE}

#using IPUMS API to access CPS ASEC 2022 data

dotenv::load_dot_env()

# Access the values
ipums_key <- Sys.getenv("ipums_api_key")

cps_extract_request <- define_extract_cps(
  description = "IPUMS-CPS, ASEC 2022",
  samples = c("cps2022_03s"),
  variables = c("CPSID", "ASECFLAG", "ASECWTH", "PERNUM", 
  "CPSIDV", "CPSIDP", "ASECWT", "AGE", 
  "SEX", "RACE", "MARST", "POPSTAT", "ASIAN", 
  "FAMSIZE", "NCHILD", "NCHLT5", "BPL", "YRIMMIG", 
  "CITIZEN", "MBPL", "FBPL", "NATIVITY", "HISPAN", 
  "EMPSTAT", "LABFORCE", "EDUC", "FTOTVAL", "INCTOT", 
  "INCWAGE", "OFFPOV", "MIGSTA1", "WHYMOVE", "MIGRATE1", 
  "HIMCAIDNW", "HIMCARENW", "ANYCOVNW", "PRVTCOVNW", 
  "GRPCOVNW", "DPCOVNW", "MRKCOVNW", "TRCCOVNW", "INHCOVNW", 
  "GOTWIC")
)

submitted_extract <- submit_extract(extract = cps_extract_request, api_key = Sys.getenv("ipums_api_key"))
downloadable_extract <- wait_for_extract(extract = submitted_extract, api_key = Sys.getenv("ipums_api_key"))
data_files <- download_extract(downloadable_extract, api_key = Sys.getenv("ipums_api_key"))


#Loading in the CPS 2022 data from IPUMS API
ddi <- read_ipums_ddi("cps_00003.xml")
cps <- read_ipums_micro(ddi)

```

\
3. Data Wrangling and Exploratory Data Analysis: This section should include your code\
to perform any data cleaning and new variable creation. You should also thoroughly\
explore your data, including assessing the presence of outliers/unexpected values and\
identifying and appropriately addressing missingness in any key variables.

```{r, eval = FALSE}

# Data Cleaning and Wrangling for CPS

cps <- cps %>%
  janitor::clean_names() %>%
  select(-year, -month, -mbpl, -fbpl, -asian)

cps_na <- is.na(cps)

missing_counts <- colSums(cps_na)

print(missing_counts[missing_counts > 0])

# missing values are ones that are not part of the ASEC supplemental, so we filter those observations out

cps <- cps %>%
  filter(!is.na(asecwth)) 

# create variable for health insurance status 

cps <- cps %>%
  mutate(healthinsu = case_when(
    himcaidnw == 1 ~ "medicaid", 
    himcarenw == 1 ~ "medicare",
    prvtcovnw == 1 ~ "private",
    grpcovnw == 1 ~ "employment based",
    dpcovnw == 1 ~ "direct purchase",
    mrkcovnw == 1 ~ "marketplace",
    trccovnw == 1 ~ "tricare", 
    inhcovnw == 1 ~ "indian health service",
    TRUE ~ NA_character_  
  )) 

cps <- cps %>%
  mutate(healthinsu = factor(healthinsu, levels = c(
    "medicaid", "medicare", "private", "employment based", 
    "direct purchase", "marketplace", "tricare", 
    "indian health service"
  ), labels = c(
    "Medicaid", "Medicare", "Private", "Employment Based", 
    "Direct Purchase", "Marketplace", "Tricare", 
    "Indian Health Service"
  )))

cps <- cps %>%
  filter(!is.na(anycovnw)) %>%
  select(-himcaidnw, -himcarenw, -prvtcovnw, -grpcovnw, -dpcovnw, -mrkcovnw, -trccovnw, -inhcovnw) %>%
  mutate(healthinsu = as_factor(healthinsu))
  

cps_svy <- as_survey_design(.data = cps, weights = asecwt) 

cps <- cps %>%
  mutate_all(as.numeric)

cps <- cps %>%
  select(-asecflag)
```

\
4. Data Analysis: This section should include the code to conduct analysis to answer your\
question of interest. It should include writing explaining why the tools you selected are\
a good fit for the research question and a justification of key analytic decisions. If you\
are using machine learning methods, this section should include model evaluation using\
the methods discussed in class.

Part A) Unsupervised Machine Learning using data from the CPS

```{r, eval = FALSE}

# correlation plot of data to highlight multicollinearity 

correlation <- cps %>%
  select(-serial, -cpsid, -asecwth, -pernum, -cpsidp, -cpsidv, -asecwt) %>%
  cor()

corrplot(correlation, method = 'color')

# creating PCA recipe 
rec_pca <- recipe(
  formula = ~ .,
  data = cps) %>%
  update_role(serial, cpsid, asecwth, pernum, cpsidp, cpsidv, asecwt, new_role = "Id") %>%
  step_scale(all_predictors()) %>%
  step_pca(all_predictors(), num_comp = 5) %>%
  prep(data = cps) 

# apply estimated loadings to original data
cps_pcs <- rec_pca %>%
  bake(new_data = cps)

# Extract Loadings
coef <- rec_pca %>%
  tidy(type = "coef", number = 2)

# Extract variance explained
variance <- rec_pca %>%
  tidy(type = "variance", number = 2) %>%
  filter(terms == "variance") %>%
  mutate(pct_var = value/sum(value)) %>%
  slice_head(n = 5) 

print(variance)

cps_pcs_all <- 
  bind_cols(cps, cps_pcs)

# making scatterplot to visualize data

plot1 <- cps_pcs_all %>%
  ggplot(mapping = aes(x = PC1, y = PC2, color = citizen)) +
  geom_point() + 
  labs(title = "Scatterplot of PC1 and PC2 by Citizenship",
       x = "Principal Component 1",
       y = "Principal Component 2") + 
  theme(plot.title = element_text(size = 12))

plot2 <- cps_pcs_all %>%
  ggplot(mapping = aes(x = PC1, y = PC2, color = healthinsu)) +
  geom_point() + 
  labs(title = "Scatterplot of PC1 and PC2 by Health Insurance Status",
       x = "Principal Component 1",
       y = "Principal Component 2") + 
  theme(plot.title = element_text(size = 12))

plot1 + plot2

# Creating a kmeans model

# set up cross-validation
folds <- vfold_cv(cps, v = 5)

kmeans_rec <- recipe(
formula = ~ .,
data = cps
) %>%
  update_role(serial, cpsid, asecwth, pernum, cpsidp, cpsidv, asecwt, new_role = "Id") %>%
  step_dummy(all_nominal(), -all_outcomes()) %>% 
  step_scale(all_predictors()) %>%
  step_center(all_predictors()) 

kmeans_numeric <- kmeans_rec %>%
prep() %>%
bake(new_data = cps)

# hyperparameter tune first to obtain optimal number of clusters

# create a kmeans model object four clusters
kmeans_spec <- k_means(
num_clusters = 4 
) %>%
set_engine(
"stats",
nstart = 100, iter.max = 1000
)

# create a workflow
kmeans_wflow <- workflow(
preprocessor = kmeans_rec,
spec = kmeans_spec
)
# set a seed because the clusters are not deterministic
set.seed(20200205)

# fit the model
fit <- kmeans_wflow %>%
fit(data = cps)

# view the model results
tidy(fit) %>%
knitr::kable(digits = 2)
```

Part B) Supervised Machine Learning using data from the CPS

```{r, eval = FALSE}
#Load in the CPS 2022 data from IPUMS with relevant immigration and health insurance variables.

ddi <- read_ipums_ddi("cps_00005.xml")
cps_ag <- read_ipums_micro(ddi)
```

```{r, eval = FALSE}
#Clean column names

cps_ag <- cps_ag %>%
  janitor::clean_names()

colnames(cps_ag) <- tolower(colnames(cps_ag))
```

```{r, eval = FALSE}
#Remove NAs

cps_ag <- subset(cps_ag, yrimmig != 0000)

cps_ag <- subset(cps_ag, paidgh != 00)

cps_ag <- subset(cps_ag, phinsur != 0)

cps_ag <- subset(cps_ag, anycovly != 99)

cps_ag <- subset(cps_ag, empstat != 00)

cps_ag <- subset(cps_ag, hhincome != 99999999)
```

```{r, eval = FALSE}
#Split data into training and testing data with the variable of interest set as "any health insurance coverage last year" (anycovly).

set.seed(20231125)
split <- initial_split(data = cps_ag, strata = "anycovly", prop = 0.8)


cps_train <- training(x = split)
cps_test <- testing(x = split)

```

```{r, eval = FALSE}
# Create a recipe for the model. Here the predictor is year since immigration (yrimmig) to predict health insurance coverage (anycovyly).

cps_rec <- 
  recipe(anycovly ~ ., data = cps_train) %>%
  step_dummy(all_nominal_predictors()) %>% 
  step_zv(all_numeric_predictors()) %>%
  step_center(all_numeric_predictors()) %>%
  step_zv(all_predictors()) %>%
  step_log(anycovly, base = 10)
  

bake(prep(cps_rec, training = cps_train), new_data = cps_train)
     
```

```{r, eval = FALSE}
# Set up v-fold cross validation with 10 folds to test the model.

set.seed(12032023)
folds <- vfold_cv(data = cps_train, v = 10)
folds
```

```{r, eval = FALSE}
# Linear Regression Model to predict health insurance coverage based on immigration year.

lm_mod <- linear_reg() %>%
  set_engine("lm")


# create a workflow
lm_wf <- workflow() %>%
  add_recipe(cps_rec) %>%
  add_model(lm_mod) 

# fit the model by piping your workflow
lm_cv <- lm_wf %>%
  fit_resamples(resamples = folds)


# select the best model based on the "rmse" metric
lm_best <- lm_cv %>%
  select_best(metric = "rmse")


# use the finalize_workflow() function with your workflow and the best model 
# to update (or "finalize") your workflow by modifying the line below
lm_final <- finalize_workflow(
  lm_wf,
  parameters = lm_best
)



lm_coefs <- lm_final %>%
  fit(data = cps_train) %>%
  extract_fit_parsnip() %>%
  vi(lambda = lasso_best$penalty)
```

```{r, eval = FALSE}
#finalize workflow
lm_final_wf <- 
  lm_wf %>% 
  finalize_workflow(lm_best)

#final fit 
lm_final_fit <- 
  lm_final_wf %>%
  last_fit(split)

# RSME or Out of sample error rate
lm_final_fit %>%
  collect_metrics(lm_final, summarize = FALSE) %>% 
  print()

#collect predictions & show testing data predictions
predictions <- 
  lm_final_fit %>% 
  collect_predictions()

```

\
5. Discussion of Results: This section should include the interpretation of your results.\
Please discuss what your results suggest about the answer to your research question\
of interest. Please also discuss any limitations of your analysis and areas for potential\
future research.
